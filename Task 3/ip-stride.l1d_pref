//
// From Data Prefetching Championship Simulator 2
// Seth Pugsley, seth.h.pugsley@intel.com
//

/*

  This file describes an Instruction Pointer-based (Program Counter-based) stride prefetcher.  
  The prefetcher detects stride patterns coming from the same IP, and then 
  prefetches additional cache lines.

  Prefetches are issued into the L1D or L2 depending on L1D MSHR occupancy.

 */

#include "cache.h"

#define IP_TRACKER_COUNT 1024
#define MIN_PREFETCH_DEGREE 3
#define PREFETCH_DEGREE 3
#define MAX_PREFETCH_DEGREE 11

// ASSGN: define CS_PREFETCH so that Task1's cache.cc changes are not affected
#define CS_PREFETCH

class IP_TRACKER1 {
  public:
    // the IP we're tracking
    uint64_t ip;

    // the last address accessed by this IP
    uint64_t last_cl_addr;

    // the stride between the last two addresses accessed by this IP
    int64_t last_stride;

    // use LRU to evict old IP trackers1
    uint32_t lru;

    // ASSGN: counter to store number of improper pre-fetches
    int cnt;
    int tot;

    IP_TRACKER1 () {
        ip = 0;
        last_cl_addr = 0;
        last_stride = 0;
        lru = 0;
        cnt = 0;
        tot = 0;
    };
};

IP_TRACKER1 trackers1[IP_TRACKER_COUNT];

// ASSGN: CS341 Assignment5 changes for Task4
int prefetch_throttle1(int index){
    // Need to vary the degree of prefetch based on prev performance
    float fr = (trackers1[index].cnt*1.0)/trackers1[index].tot;
    int x = MIN_PREFETCH_DEGREE + (MAX_PREFETCH_DEGREE - MIN_PREFETCH_DEGREE)*fr;
    return x;
    // return PREFETCH_DEGREE;
}

void CACHE::l1d_prefetcher_initialize() 
{
    cout << "CPU " << cpu << " L1D IP-based stride prefetcher" << endl;
    for (int i=0; i<IP_TRACKER_COUNT; i++)
        trackers1[i].lru = i;
}

void CACHE::l1d_prefetcher_operate(uint64_t addr, uint64_t ip, uint8_t cache_hit, uint8_t type)
{
    // check for a tracker hit
    uint64_t cl_addr = addr >> LOG2_BLOCK_SIZE;

    int index = -1;
    for (index=0; index<IP_TRACKER_COUNT; index++) {
        if (trackers1[index].ip == ip)
            break;
    }

    // this is a new IP that doesn't have a tracker yet, so allocate one
    if (index == IP_TRACKER_COUNT) {

        for (index=0; index<IP_TRACKER_COUNT; index++) {
            if (trackers1[index].lru == (IP_TRACKER_COUNT-1))
                break;
        }

        trackers1[index].ip = ip;
        trackers1[index].last_cl_addr = cl_addr;
        trackers1[index].last_stride = 0;

        //cout << "[IP_STRIDE] MISS index: " << index << " lru: " << trackers1[index].lru << " ip: " << hex << ip << " cl_addr: " << cl_addr << dec << endl;

        for (int i=0; i<IP_TRACKER_COUNT; i++) {
            if (trackers1[i].lru < trackers1[index].lru)
                trackers1[i].lru++;
        }
        trackers1[index].lru = 0;

        //return metadata_in;
        return;
    }

    // sanity check
    // at this point we should know a matching tracker index
    if (index == -1)
        assert(0);

    // calculate the stride between the current address and the last address
    // this bit appears overly complicated because we're calculating
    // differences between unsigned address variables
    int64_t stride = 0;
    if (cl_addr > trackers1[index].last_cl_addr)
        stride = cl_addr - trackers1[index].last_cl_addr;
    else {
        stride = trackers1[index].last_cl_addr - cl_addr;
        stride *= -1;
    }

    //cout << "[IP_STRIDE] HIT  index: " << index << " lru: " << trackers1[index].lru << " ip: " << hex << ip << " cl_addr: " << cl_addr << dec << " stride: " << stride << endl;

    // don't do anything if we somehow saw the same address twice in a row
    if (stride == 0)
        //return metadata_in;
        return;

    // only do any prefetching if there's a pattern of seeing the same
    // stride more than once
    if (stride == trackers1[index].last_stride) {
        // Increment tot and if hit, then increment cnt
        trackers1[index].tot++;
        if(cache_hit==1) trackers1[index].cnt++;

        // ASSGN: do some prefetching
        for (int i=0; i<prefetch_throttle1(index); i++) {
            uint64_t pf_address = (cl_addr + (stride*(i+1))) << LOG2_BLOCK_SIZE;

            // only issue a prefetch if the prefetch address is in the same 4 KB page 
            // as the current demand access address
            if ((pf_address >> LOG2_PAGE_SIZE) != (addr >> LOG2_PAGE_SIZE))
                break;

            // check the MSHR occupancy to decide if we're going to prefetch to the L1D or L2
            if (MSHR.occupancy < (MSHR.SIZE>>1))
	      prefetch_line(ip, addr, pf_address, FILL_L1, 0);
            else
	      prefetch_line(ip, addr, pf_address, FILL_L2, 0);
        }
    }

    trackers1[index].last_cl_addr = cl_addr;
    trackers1[index].last_stride = stride;

    for (int i=0; i<IP_TRACKER_COUNT; i++) {
        if (trackers1[i].lru < trackers1[index].lru)
            trackers1[i].lru++;
    }
    trackers1[index].lru = 0;

    //return metadata_in;
    return;
}

void CACHE::l1d_prefetcher_cache_fill(uint64_t addr, uint32_t set, uint32_t way, uint8_t prefetch, uint64_t evicted_addr, uint32_t metadata_in)
{
  //return metadata_in;
  return;
}

void CACHE::l1d_prefetcher_final_stats()
{
    cout << "CPU " << cpu << " L1D PC-based stride prefetcher final stats" << endl;
}
